
import json
from typing import Any
import urllib.parse
from .base64_generator import Base64Generator
class XscGenerator:
    def __init__(self,a1,x8) -> None:
        self.a1 = a1
        self.x8 = x8
        self.s: list[int] = [
            0,
            1996959894,
            3993919788,
            2567524794,
            124634137,
            1886057615,
            3915621685,
            2657392035,
            249268274,
            2044508324,
            3772115230,
            2547177864,
            162941995,
            2125561021,
            3887607047,
            2428444049,
            498536548,
            1789927666,
            4089016648,
            2227061214,
            450548861,
            1843258603,
            4107580753,
            2211677639,
            325883990,
            1684777152,
            4251122042,
            2321926636,
            335633487,
            1661365465,
            4195302755,
            2366115317,
            997073096,
            1281953886,
            3579855332,
            2724688242,
            1006888145,
            1258607687,
            3524101629,
            2768942443,
            901097722,
            1119000684,
            3686517206,
            2898065728,
            853044451,
            1172266101,
            3705015759,
            2882616665,
            651767980,
            1373503546,
            3369554304,
            3218104598,
            565507253,
            1454621731,
            3485111705,
            3099436303,
            671266974,
            1594198024,
            3322730930,
            2970347812,
            795835527,
            1483230225,
            3244367275,
            3060149565,
            1994146192,
            31158534,
            2563907772,
            4023717930,
            1907459465,
            112637215,
            2680153253,
            3904427059,
            2013776290,
            251722036,
            2517215374,
            3775830040,
            2137656763,
            141376813,
            2439277719,
            3865271297,
            1802195444,
            476864866,
            2238001368,
            4066508878,
            1812370925,
            453092731,
            2181625025,
            4111451223,
            1706088902,
            314042704,
            2344532202,
            4240017532,
            1658658271,
            366619977,
            2362670323,
            4224994405,
            1303535960,
            984961486,
            2747007092,
            3569037538,
            1256170817,
            1037604311,
            2765210733,
            3554079995,
            1131014506,
            879679996,
            2909243462,
            3663771856,
            1141124467,
            855842277,
            2852801631,
            3708648649,
            1342533948,
            654459306,
            3188396048,
            3373015174,
            1466479909,
            544179635,
            3110523913,
            3462522015,
            1591671054,
            702138776,
            2966460450,
            3352799412,
            1504918807,
            783551873,
            3082640443,
            3233442989,
            3988292384,
            2596254646,
            62317068,
            1957810842,
            3939845945,
            2647816111,
            81470997,
            1943803523,
            3814918930,
            2489596804,
            225274430,
            2053790376,
            3826175755,
            2466906013,
            167816743,
            2097651377,
            4027552580,
            2265490386,
            503444072,
            1762050814,
            4150417245,
            2154129355,
            426522225,
            1852507879,
            4275313526,
            2312317920,
            282753626,
            1742555852,
            4189708143,
            2394877945,
            397917763,
            1622183637,
            3604390888,
            2714866558,
            953729732,
            1340076626,
            3518719985,
            2797360999,
            1068828381,
            1219638859,
            3624741850,
            2936675148,
            906185462,
            1090812512,
            3747672003,
            2825379669,
            829329135,
            1181335161,
            3412177804,
            3160834842,
            628085408,
            1382605366,
            3423369109,
            3138078467,
            570562233,
            1426400815,
            3317316542,
            2998733608,
            733239954,
            1555261956,
            3268935591,
            3050360625,
            752459403,
            1541320221,
            2607071920,
            3965973030,
            1969922972,
            40735498,
            2617837225,
            3943577151,
            1913087877,
            83908371,
            2512341634,
            3803740692,
            2075208622,
            213261112,
            2463272603,
            3855990285,
            2094854071,
            198958881,
            2262029012,
            4057260610,
            1759359992,
            534414190,
            2176718541,
            4139329115,
            1873836001,
            414664567,
            2282248934,
            4279200368,
            1711684554,
            285281116,
            2405801727,
            4167216745,
            1634467795,
            376229701,
            2685067896,
            3608007406,
            1308918612,
            956543938,
            2808555105,
            3495958263,
            1231636301,
            1047427035,
            2932959818,
            3654703836,
            1088359270,
            936918000,
            2847714899,
            3736837829,
            1202900863,
            817233897,
            3183342108,
            3401237130,
            1404277552,
            615818150,
            3134207493,
            3453421203,
            1423857449,
            601450431,
            3009837614,
            3294710456,
            1567103746,
            711928724,
            3020668471,
            3272380065,
            1510334235,
            755167117
        ]
        self.cust_base64_chars_list=[
            "Z", "m", "s", "e", "r", "b", "B", "o", "H", "Q", "t", "N", "P", "+", "w", "O", 
            "c", "z", "a", "/", "L", "p", "n", "g", "G", "8", "y", "J", "q", "4", "2", "K", 
            "W", "Y", "j", "0", "D", "S", "f", "d", "i", "k", "x", "3", "V", "T", "1", "6", 
            "I", "l", "U", "A", "F", "M", "9", "7", "h", "E", "C", "v", "u", "R", "X", "5"
        ]

    def get_x9(self) -> int:
        # CRC-32标准查询表，对应于多项式 0xEDB88320

        
        # JavaScript中的 a = 3988292384
        # 在 Python 中，由于数字大小超过 2^31 - 1，默认是正整数。
        # 保持为正整数，最后通过位操作处理带符号整数。
        a = 3988292384 
        
        # 检查输入是否为字符串
        if isinstance(self.x8, str):
            # JavaScript中的 c = -1 相当于 32位无符号整数 0xFFFFFFFF
            # Python 中的初始 CRC 值，使用 32 位掩码确保操作在 32 位范围内
            c = 0xFFFFFFFF
            
            # 迭代字符串中的每个字符
            for char in self.x8:
                # e.charCodeAt(r) 获取字符的 Unicode 编码点，这里假设为 ASCII 或 UTF-8
                # 255 & c ^ char_code 获取低 8 位与字符编码进行异或操作，得到查询表的索引
                # s[...] ^ c >>> 8：查询表值与 c 右移 8 位（相当于除以 2^8）进行异或
                # JavaScript 的 >>> 8 是无符号右移，Python 的 >> 默认是算术右移。
                # 对于正数 c，c >> 8 即可。对于 c=0xFFFFFFFF (初始值)，无符号右移是 0x00FFFFFF。
                
                char_code = ord(char)
                
                # (255 & c) ^ char_code 是索引
                index = (c & 0xFF) ^ char_code
                
                # Python 的 c >> 8 相当于 JavaScript 的 c >>> 8（因为 c 保持在 32 位无符号正数范围内）
                c = self.s[index] ^ (c >> 8)
                
                # 使用 32 位掩码保持 c 在 32 位无符号整数范围内 (0 到 4294967295)
                # 这在 Python 中是必要的，因为整数可以任意大
                c &= 0xFFFFFFFF

            # return -1 ^ c ^ a
            # 1. -1 ^ c：在 32 位补码系统中，-1 对应 0xFFFFFFFF，所以 -1 ^ c 相当于 (0xFFFFFFFF ^ c)
            #    -1 ^ c 也就是 CRC 的最终异或操作，等同于 ~c (按位取反)。
            final_crc = c ^ 0xFFFFFFFF
            
            # 2. ^ a：再与 a (3988292384) 异或
            result_unsigned = final_crc ^ a
            
            # 3. 转换为有符号 32 位整数（JavaScript 的数字类型行为）
            # 如果 result_unsigned 大于或等于 2^31 (2147483648)，则结果是负数
            # 0x80000000 = 2147483648
            if result_unsigned & 0x80000000:
                # 这是一个负数，减去 2^32 得到其带符号表示
                return result_unsigned - 0x100000000
            else:
                return result_unsigned
        else:
            # 如果输入不是字符串，根据 JS 代码行为（返回 undefined），这里可以返回 None 或抛出错误
            # 保持与 JS 逻辑一致，但处理为数值操作可能更实用
            return a

    def triplet_to_base64(self,e):
        """
        将 3 个字节（存储在 32 位整数 e 中）编码为 4 个 Base64 字符。
        对应于 JavaScript 的 tripletToBase64(e)。
        
        Args:
            e (int): 包含 3 字节数据的 32 位整数 (0xBBBBBB)。
            c (list): Base64 查找表。
            
        Returns:
            str: 4 个 Base64 字符。
        """
        # JS: c[e >> 18 & 63] + c[e >> 12 & 63] + c[e >> 6 & 63] + c[63 & e]
        # e >> 18 & 63: 第一个 6 位 (高位)
        # e >> 12 & 63: 第二个 6 位
        # e >> 6 & 63:  第三个 6 位
        # 63 & e:       第四个 6 位 (低位)
        
        char1 = self.cust_base64_chars_list[(e >> 18) & 63]
        char2 = self.cust_base64_chars_list[(e >> 12) & 63]
        char3 = self.cust_base64_chars_list[(e >> 6) & 63]
        char4 = self.cust_base64_chars_list[e & 63]
        
        return char1 + char2 + char3 + char4

    def encode_chunk(self,e, a, r):
        """
        对字节数组 e 从索引 a 到 r 进行分块编码。
        对应于 JavaScript 的 encodeChunk(e, a, r)。
        
        Args:
            e (list[int]): UTF-8 字节数组。
            a (int): 起始索引。
            r (int): 结束索引 (不包含)。
            c (list): Base64 查找表。
            
        Returns:
            str: 编码后的 Base64 字符串片段。
        """
    
        # 结果列表
        d = []
        
        # 遍历字节数组，步长为 3
        s = a
        while s < r:
            # c = (e[s] << 16 & 0xff0000) + (e[s + 1] << 8 & 65280) + (255 & e[s + 2])
            # 将 3 个字节 (e[s], e[s+1], e[s+2]) 合并成一个 24 位整数 'c'。
            # JS 中的 & 0xff0000 和 & 65280 (0xFF00) 确保操作在 24 位内，但在 Python 中，
            # 由于默认整数行为，可以直接进行左移。
            
            byte1 = e[s]
            # 确保索引有效，如果 r 是数组末尾，这些索引应该存在。
            # 这里的 JS 逻辑是假设 r 是 3 字节块的倍数，在 b64Encode 中，r 始终是 l (r - d)
            # 也就是处理完整 3 字节块的界限，所以不需要额外边界检查。
            byte2 = e[s + 1]
            byte3 = e[s + 2]
            
            # 0xFFFFFF 掩码是可选的，因为我们知道这 3 个字节不会超过 2^24 - 1
            c_val = (byte1 << 16) | (byte2 << 8) | byte3
            
            # 将 24 位整数编码为 4 个字符
            d.append(self.triplet_to_base64(c_val))
            
            s += 3
            
        return "".join(d)

    def encode_utf8(self,e):
        # 对字符串进行 URL 编码（类似于 JavaScript 的 encodeURIComponent）
        a = urllib.parse.quote(e)
        r = []
        c = 0
        
        while c < len(a):
            d = a[c]
            if d == "%":
                # 提取 % 后面的两个十六进制字符并转换为整数
                hex_str = a[c+1:c+3]
                s = int(hex_str, 16)
                r.append(s)
                c += 3
            else:
                # 将字符转换为 ASCII 码
                r.append(ord(d))
                c += 1
        
        return r


    def b64_encode(self,e):
        """
        主 Base64 编码函数。
        对应于 JavaScript 的 b64Encode(e)。
        
        Args:
            e (list[int]): UTF-8 字节数组（通过 encode_utf8 获得）。
            c (list): Base64 查找表。
            
        Returns:
            str: 最终的 Base64 编码字符串。
        """
        # 长度
        r = len(e)
        # 尾部剩余的字节数
        d = r % 3
        # 结果片段列表
        s = []
        # 分块处理的大小（16383 是为了防止 JS 中数组/字符串操作导致的性能问题，Python 中可以忽略）
        f = 16383 
        # 当前处理的起始索引
        u = 0
        # 完整 3 字节块的长度界限
        l = r - d 
        
        # 完整块处理 (u < l)
        while u < l:
            # 计算当前块的结束索引
            end = min(u + f, l)
            s.append(self.encode_chunk(e, u, end))
            u = end # 移动到下一个块的开始

        # --- 处理尾部填充 ---
        
        if d == 1:
            # 剩余 1 字节：A (8位) -> B64(6位) B64(2位+4个0) ==
            # JS: a = e[r - 1]
            # JS: c[a >> 2] + c[a << 4 & 63] + "=="
            
            a = e[r - 1]
            char1 = self.cust_base64_chars_list[a >> 2]               # 8位中的高 6 位
            char2 = self.cust_base64_chars_list[(a << 4) & 63]        # 8位中的低 2 位 (左移 4 位, 补足 6 位)
            s.append(char1 + char2 + "==")
            
        elif d == 2:
            # 剩余 2 字节：A (8位) B (8位) -> B64(6位) B64(6位) B64(4位+2个0) =
            # JS: a = (e[r - 2] << 8) + e[r - 1]
            # JS: c[a >> 10] + c[a >> 4 & 63] + c[a << 2 & 63] + "="
            
            # 将最后两个字节合并为 16 位整数 'a'
            a = (e[r - 2] << 8) | e[r - 1]
            
            char1 = self.cust_base64_chars_list[a >> 10]              # 16位中的高 6 位
            char2 = self.cust_base64_chars_list[(a >> 4) & 63]        # 16位中的中间 6 位
            char3 = self.cust_base64_chars_list[(a << 2) & 63]        # 16位中的低 4 位 (左移 2 位, 补足 6 位)
            s.append(char1 + char2 + char3 + "=")
            
        return "".join(s)

    def get_sxc(self):
        x9= self.get_x9()
        y: dict[str, Any] = {
            "s0": 5,
            "s1": "",
            "x0": "1",
            "x1": "4.2.6",
            "x2": "Windows",
            "x3": "xhs-pc-web",
            "x4": "4.86.0",
            "x5": self.a1,
            "x6": "",
            "x7": "",
            "x8": self.x8,
            "x9": x9,
            "x10": 0,
            "x11": "normal"
        }  
        print("x9",x9)
        base64generator=Base64Generator()
        result=base64generator.b64_encode(y)
        return result

# a1 = "19ab462768dbnostuyyqujnz1j5fyrt8egmfrrr1n50000440764"


def get_xsc(a1,e):
    
    xscencrpt=XscGenerator(a1=a1,x8=e)
    xsc=xscencrpt.get_sxc()
    return xsc






